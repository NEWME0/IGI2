//------------------------------------------------
//--- 010 Editor v9.0.1 Binary Template
//
//      File: IGI2_MEF.bt
//   Authors: Rotari Artiom
//   Version: 1.0
//   Purpose: 
//  Category: Game
// File Mask: ILFF
//  ID BYTEs: 
//   History: 
//------------------------------------------------


#include "COMMON/ILFF.bt";
#include "COMMON/ALIGN.bt";
#include "COMMON/STRINGS.bt";
#include "COMMON/FVECTORS.bt";
#include "COMMON/DATETIME.bt";
#include "COMMON/TOOLS.bt";


struct HBONE;


void Padding(){
    if(header.block_size > 0)
        BYTE padding[header.block_size - header.data_size - 16] <hidden=true>;
}


LittleEndian();


enum <UINT32> MODELTYPE
{
    MODEL_RIGID = 0,
    MODEL_BONE = 1,
    MODEL_LIGHTMAP = 3,
};


typedef struct
{
    UBYTE child_count;

    local UBYTE boneid = id++;
    local UBYTE i = 0;

    for(i = 0; i < child_count; i++)
        HBONE bone;
} HBONE <read=Read_HBONE>;



typedef struct HSEM
{
    ILFF_HEADER header;

    FLOAT    _00;               // {0.1599999964237213}
    DATETIME  DateTime;
    MODELTYPE modeltype;         // {0, 1, 3}
    UINT32   _09;               // {0}
    UINT32   _10;               // {0}
    UINT32   _11;               // {0}

    FLOAT    _12;               // [-1197574.5         - 588632.5625],   2708
    FLOAT    _13;               // [-551761.5625       - 164895.65625],  2704
    FLOAT    _14;               // [-1004530.75        - 245571.46875],  2689
    FLOAT    _15;               // [ 0.0               - 4107811.25],    2714
    FLOAT    _16;               // [-1197574.5         - 588632.5625],   2763
    FLOAT    _17;               // [-450069.625        - 166205.71875],  2751
    FLOAT    _18;               // [-1004220.0         - 224238.328125], 2733
    FLOAT    _19;               // [ 8.636710166931152 - 4107811.25],    2740
    FLOAT    _20;               // [-1197574.5         - 588632.5625],   2763
    FLOAT    _21;               // [-450069.625        - 166205.71875],  2751
    FLOAT    _22;               // [-1004220.0         - 224238.328125], 2733
    FLOAT    _23;               // [ 8.636710166931152 - 4107811.25],    2740

    UINT32   rendermesh_face_count;
    UINT32   rendermesh_vertex_count;
    UINT32   rendermesh_buffer_size;     // d3dr, efac, dner, xtrv, pmtl
    UINT32   collisionmesh_face_count;
    UINT32   collisionmesh_vertex_count;
    UINT32   collisionmesh_buffer_size;  // xtvc0, ecfc0, tamc0, hpsc0, xtvc1, ecfc1, tamc1, hpsc1
    FLOAT    _30;                        // [16.031251907348633 .. 5001837.0], 1993
    UINT16   magic_vertex_count;
    UINT16   attachment_count;
    UINT16   portal_vertex_count;
    UINT16   portal_face_count;
    UINT16   portal_count;
    UINT16   bone_count;
    UINT16   glow_count;
    UBYTE    reserved1[30];     // {0, 43947}
    UBYTE    reserved2[8];      // {0}

    Padding();
};


// BONES
// BONE HIERARCHY
typedef struct REIH
{
    ILFF_HEADER header;

    local UBYTE id = 0;
    HBONE root;

    Align(4);

    FVECTOR3 bone_position[id];

    Padding();
};

// BONE NAMES
typedef struct MANB
{
    ILFF_HEADER header;

    FSTRING bone_name(16)[header.data_size / 16];

    Padding();
};


// ATTACHMENTS
// ATTACHMENT DEFINE
typedef struct ATTA
{
    ILFF_HEADER header;

    struct
    {
        CHAR  name[16];
        FLOAT x;
        FLOAT y;
        FLOAT z;
        FLOAT _04;  // [-1.0 .. 1.0], 229
        FLOAT _05;  // [-1.0 .. 1.0], 297
        FLOAT _06;  // [-1.0 .. 1.0], 219
        FLOAT _07;  // [-1.0 .. 1.0], 304
        FLOAT _08;  // [-1.0 .. 1.0], 245
        FLOAT _09;  // [-1.0 .. 1.0], 191
        FLOAT _10;  // [-1.0 .. 1.0], 255
        FLOAT _11;  // [-1.0 .. 1.0], 244
        FLOAT _12;  // [-1.0 .. 1.0], 93
        int   _13;  // {0, 2880154539}
        int   _14;  // {0, 4, -1, 15}
    } attachment[header.data_size / 72];

    Padding();
};


// MAGIC VERTEX
// MAGIC VERTICES
typedef struct XTVM
{
    ILFF_HEADER header;

    struct
    {
        UINT32 _00;
        UINT32 _01;
        UINT32 _02;
        UINT32 _03;
    } unk[header.data_size / 16];

    Padding();
};


// PORTALS
// PORTAL DEFINE
typedef struct TROP
{
    ILFF_HEADER header;

    struct
    {
        UINT32 vrtx_offset;
        UINT32 vrtx_count;
        UINT32 face_offset;
        UINT32 face_count;
        UINT32 _0;
    } unk[header.data_size / 20];

    Padding();
};

// PORTAL VERTICES
typedef struct XVTP
{
    ILFF_HEADER header;

    struct
    {
        FLOAT x;
        FLOAT y;
        FLOAT z;
    } vertex[header.data_size / 12];

    Padding();
};

// PORTAL FACES
typedef struct CFTP
{
    ILFF_HEADER header;

    struct
    {
        UINT32 a;
        UINT32 b;
        UINT32 c;
    } face[header.data_size / 12];

    Padding();
};


// GLOWS
// GLOW DEFINE
typedef struct WOLG
{
    ILFF_HEADER header;

    struct
    {
        FLOAT  _0;
        FLOAT  _1;
        FLOAT  _2;
        FLOAT  _3;
        FLOAT  _4;
        FLOAT  _5;
        FLOAT  _6;
        UINT32 _7;
    } glow[header.data_size / 32];

    Padding();
};


// RENDER MESH BLOCKS
// RENDER MESH HEADER
typedef struct D3DR
{
    ILFF_HEADER header;

    switch(header.data_size)
    {
        case 36:
            UINT32 _four;
            UINT32 face_count;
            UINT32 rendermesh_count;
            UINT32 vertex_count;
            UINT32 _04;
            UINT32 _05;
            UINT32 _06;
            UINT32 _07;
            UINT32 _08;
        break;

        case 40:
            UINT32 _four;
            UINT32 face_count;
            UINT32 rendermesh_count;
            UINT32 _03;
            UINT32 _04;
            UINT32 vertex_count;
            UINT32 _06;
            UINT32 _07;
            UINT32 _08;
            UINT32 _09;
        break;

        case 44:
            UINT32 _four;
            UINT32 _01;
            UINT32 face_count;
            UINT32 rendermesh_count;
            UINT32 vertex_count;
            UINT32 _05;
            UINT32 _06;
            UINT32 _07;
            UINT32 _08;
            UINT32 _09;
            UINT32 _10;
        break;
    }

    Padding();
};

// RENDER MESH FACES
typedef struct ECAF
{
    ILFF_HEADER header;

    struct
    {
        UINT16 a;
        UINT16 b;
        UINT16 c;
    } face[parentof(this).d3dr.face_count];

    Padding();
};

// RENDER MESH DEFINE
typedef struct DNER
{
    ILFF_HEADER header;

    switch(parentof(this).d3dr.header.data_size)
    {
        case 36:
        case 40:
            struct
            {
                UINT32 _00;
                FLOAT  _01;
                FLOAT  _02;
                FLOAT  _03;
                UINT16 index_offset;
                UINT16 index_count;
                UINT16 vertex_offset;
                UINT16 vertex_count;
                UINT16 id;
                INT32  _09;
                UINT16 _10;
            } rendermesh[parentof(this).d3dr.rendermesh_count];
        break;

        case 44:
            struct
            {
                UINT32 _00;
                FLOAT  _01;
                FLOAT  _02;
                FLOAT  _03;
                UINT16 _04;
                UINT16 _05;
                UINT16 _06;
                UINT16 _07;
                UINT32 _08;
            } rendermesh[parentof(this).d3dr.rendermesh_count];
        break;
    }

    Padding();
};

// RENDER MESH VERTICES
typedef struct XTRV
{
    ILFF_HEADER header;

    switch(parentof(this).d3dr.header.data_size)
    {
        case 36:
            struct
            {
                FLOAT _00;
                FLOAT _01;
                FLOAT _02;
                FLOAT _03;
                FLOAT _04;
                FLOAT _05;
                FLOAT _06;
                FLOAT _07;
            } vertex[parentof(this).d3dr.vertex_count];
        break;

        case 40:
            struct
            {
                FLOAT _00;
                FLOAT _01;
                FLOAT _02;
                FLOAT _03;
                FLOAT _04;
                FLOAT _05;
                FLOAT _06;
                FLOAT _07;
                FLOAT _08;
                FLOAT _09;
            } vertex[parentof(this).d3dr.vertex_count];
        break;

        case 44:
            struct
            {
                FLOAT _00;
                FLOAT _01;
                FLOAT _02;
                FLOAT _03;
                FLOAT _04;
                FLOAT _05;
                FLOAT _06;
            } vertex[parentof(this).d3dr.vertex_count];
        break;
    }

    Padding();
};

// RENDER MESH LIGHTMAPS
typedef struct PMTL
{
    ILFF_HEADER header;

    struct
    {
        UINT32 _00;
        UINT32 _01;
    } unk[header.data_size / 8];

    Padding();
};


// COLLISION MESH BLOCKS
// COLLISION MESH HEADER
typedef struct HSMC
{
    ILFF_HEADER header;

    UINT32 face_count_1;
    UINT32 vertex_count_1;
    UINT32 material_count_1;
    UINT32 sph_count_1;
    UINT32 _0;           // 0
    UINT32 _1;           // 0
    UINT32 _2;           // 0
    UINT32 _3;           // 0
    UINT32 face_count_2;
    UINT32 vertex_count_2;
    UINT32 material_count_2;
    UINT32 sph_count_2;
    UINT32 _4;           // 0
    UINT32 _5;           // 0
    UINT32 _6;           // 0
    UINT32 _7;           // 0

    Padding();
};

// COLLISION MESH VERTICES
typedef struct XTVC
{
    ILFF_HEADER header;

    struct
    {
        FLOAT x;
        FLOAT y;
        FLOAT z;
        FLOAT _1;
        FLOAT _2;
    } vertex[header.data_size / 20];

    Padding();
};

// COLLISION MESH FACES
typedef struct ECFC
{
    ILFF_HEADER header;

    struct
    {
        UINT16 a;
        UINT16 b;
        UINT16 c;
        UINT16 _03;
        UINT16 _04;
        UINT16 _05;
    } face[header.data_size / 12];

    Padding();
};

// COLLISION MESH MATERIALS
typedef struct TAMC
{
    ILFF_HEADER header;

    struct
    {
        INT16 _00;
        INT16 _01;
        INT16 _02;
        INT16 _03;
        INT16 _04;
        INT16 _05;
        INT16 _06;
        INT16 _07;
    } unk[header.data_size / 16];

    Padding();
};

// COLLISION MESH SPH
typedef struct HPSC
{
    ILFF_HEADER header;

    struct
    {
        FLOAT _00;
        FLOAT _01;
        FLOAT _02;
        FLOAT _03;
        INT16 _04;
        INT16 _05;
        INT16 _06;
        INT16 _07;
    } unk [header.data_size / 24];

    Padding();
};


// MORPHS
// MORPH VERTICES
typedef struct HPRM
{
    ILFF_HEADER header;

    struct
    {
        UINT32 _00;
        UINT32 _01;
        UINT32 _02;
        UINT32 _03;
    } unk[header.data_size / 16];

    Padding();
};


// TXAN

typedef struct TXAN
{
    ILFF_HEADER header;

    UINT32 _00; // {25}
    UINT32 _01; // {26}
    UINT32 _02; // {0}
    UINT32 _03; // {1}
    UINT32 _04; // {2}
    UINT32 _05; // {3}
    UINT32 _06; // {4}
    UINT32 _07; // {5}
    UINT32 _08; // {6}
    UINT32 _09; // {7}
    UINT32 _10; // {8}
    UINT32 _11; // {9}
    UINT32 _12; // {10}
    UINT32 _13; // {11}
    UINT32 _14; // {12}
    UINT32 _15; // {13}
    UINT32 _16; // {14}
    UINT32 _17; // {15}
    UINT32 _18; // {16}
    UINT32 _19; // {17}
    UINT32 _20; // {18}
    UINT32 _21; // {19}
    UINT32 _22; // {20}
    UINT32 _23; // {21}
    UINT32 _24; // {22}
    UINT32 _25; // {23}
    UINT32 _26; // {24}
    UINT32 _27; // {25}

    Padding();
};


// SHADOW MESH BLOCKS
// SHADOW MESH DEFINE
typedef struct SEMS
{
    ILFF_HEADER header;

    struct
    {
        INT32 face_offset;
        INT32 vertex_offset;
        INT32 edge_offset;
        INT32 face_count;
        INT32 vertex_count;
        INT32 edge_count;
        INT32 _0;           // {-1}
    } shadowmesh[header.data_size / 28];

    Padding();
};

// SHADOW MESH VERTICES
typedef struct XTVS
{
    ILFF_HEADER header;

    struct
    {
        FLOAT x;
        FLOAT y;
        FLOAT z;
    } vertex[header.data_size / 12];

    Padding();
};

// SHADOW MESH FACES
typedef struct CAFS
{
    ILFF_HEADER header;

    struct
    {
        UINT32 a;
        UINT32 b;
        UINT32 c;
        UINT32 _0;
        FLOAT  x;
        FLOAT  y;
        FLOAT  z;
    } face[header.data_size / 28];

    Padding();
};

// SHADOW MESH EDGES
typedef struct EGDE
{
    ILFF_HEADER header;

    struct
    {
        UINT32 a;
        UINT32 b;
    } edge[header.data_size / 8];

    Padding();
};



struct
{
    ILFF_HEADER header;
    CHAR signature[4];  // OCEM

    while(FTell() < FileSize())
    {
        switch(ReadString(FTell(), 4))
        {
            case "HSEM": HSEM hsem; break;
            case "REIH": REIH reih; break;
            case "MANB": MANB manb; break;
            case "ATTA": ATTA atta; break;
            case "XTVM": XTVM xtvm; break;
            case "TROP": TROP trop; break;
            case "XVTP": XVTP xvtp; break;
            case "CFTP": CFTP cftp; break;
            case "WOLG": WOLG wolg; break;
            case "D3DR": D3DR d3dr; break;
            case "ECAF": ECAF ecaf; break;
            case "DNER": DNER dner; break;
            case "XTRV": XTRV xtrv; break;
            case "PMTL": PMTL pmtl; break;
            case "HSMC": HSMC hsmc; break;
            case "XTVC": XTVC xtvc; break;
            case "ECFC": ECFC ecfc; break;
            case "TAMC": TAMC tamc; break;
            case "HPSC": HPSC hpsc; break;
            case "HPRM": HPRM hprm; break;
            case "TXAN": TXAN txan; break;
            case "SEMS": SEMS sems; break;
            case "XTVS": XTVS xtvs; break;
            case "CAFS": CAFS cafs; break;
            case "EGDE": EGDE egde; break;
            default: Assert(false, "Parsing error: unhandled block type");
        }
    }
} igi2_mef;


Assert(FEof(), "Parsing error: expected end of file");



string Read_HBONE(HBONE &o)
{
    return igi2_mef.manb.bone_name[o.boneid].value;
};

//------------------------------------------------
//--- 010 Editor v9.0.1 Binary Template
//
//      File: IGI2_MEF.bt
//   Authors: Rotari Artiom
//   Version: 1.0
//   Purpose: 
//  Category: Game
// File Mask: ILFF
//  ID BYTEs: 
//   History: 
//------------------------------------------------


#include "../COMMON/TYPES.bt";
#include "../COMMON/ILFF.bt";
#include "../COMMON/ALIGNMENT.bt";
#include "../COMMON/STRINGS.bt";
#include "../COMMON/VECTORS.bt";
#include "../COMMON/DATETIME.bt";



LittleEndian();


enum <U4> MT
{
    MODEL_RIGID    = 0,
    MODEL_BONE     = 1,
    MODEL_LIGHTMAP = 3,
};


typedef struct HSEM
{
    ILFF_HEADER header;

    U4 _0;
    U4 yy;
    U4 mm;
    U4 dd;
    U4 hh;
    U4 mn;
    U4 ss;
    U4 ms;
    U4 mt;
    U4 _1;
    U4 _2;
    U4 _3;
    F4 f0;
    F4 f1;
    F4 f2;
    F4 f3;
    F4 f4;
    F4 f5;
    F4 f6;
    F4 f7;
    F4 f8;
    F4 f9;
    F4 fa;
    F4 fb;
    U4 _4;
    U4 _5;
    U4 _6;
    U4 _7;
    U4 _8;
    U4 _9;
    F4 fc;
    U2 _a;
    U2 _b;
    U2 _c;
    U2 _d;
    U2 _e;
    U2 _f;
    U1 rs[20];

    Padding();
};

// ATTACHMENT DEFINE
typedef struct ATTA
{
    ILFF_HEADER header;

    struct
    {
        CH  name[16];
        F4 px;
        F4 py;
        F4 pz;
        F4 _0;
        F4 _1;
        F4 _2;
        F4 _3;
        F4 _4;
        F4 _5;
        F4 _6;
        F4 _7;
        F4 _8;
        S4 _9;
    } attachment[header.datasize / 68];

    Padding();
};

// MAGIC VERTICES
typedef struct XTVM
{
    ILFF_HEADER header;

    struct
    {
        F4 px;
        F4 py;
        F4 pz;
        S4 _0;
    } vertex[header.datasize / 16];

    Padding();
};

// PORTAL DEFINE
typedef struct TROP
{
    ILFF_HEADER header;

    struct
    {
        U4 o_vertex;
        U4 n_vertex;
        U4 o_face;
        U4 n_face;
        U4 id;
    } portal[header.datasize / 20];

    Padding();
};

// PORTAL VERTICES
typedef struct XVTP
{
    ILFF_HEADER header;

    struct
    {
        F4 px;
        F4 py;
        F4 pz;
    } vertex[header.datasize / 12];

    Padding();
};

// PORTAL FACES
typedef struct CFTP
{
    ILFF_HEADER header;

    struct
    {
        U4 a;
        U4 b;
        U4 c;
    } face[header.datasize / 12];

    Padding();
};

// RENDER MESH HEADER
typedef struct D3DR
{
    ILFF_HEADER header;

    switch(igi1_mef.hsem.mt)
    {
        case 0:
            U4 _0; // 4
            U4 tc;
            U4 mc;
            U4 vc;
            U4 _4; // 0
            U4 _5; // 0
            U4 _6; // 0
            U4 _7; // 0
            U4 _8; // 0
            U4 _9; // 0
            U4 _a; // 0
            U4 _b; // 0
        break;

        case 1:
            U4 _0; // 4
            U4 _1;
            U4 mc;
            U4 _3;
            U4 _4;
            U4 _5;
            U4 _6; // 0
            U4 _7; // 0
            U4 _8; // 0
            U4 _9; // 0
            U4 _a; // 0
            U4 _b; // 0
            U4 _c; // 0
            U4 _d; // 0
        break;

        case 3:
            U4 _0; // 4
            U4 _1;
            U4 _2;
            U4 mc;
            U4 _4;
            U4 _5; // 0
            U4 _6;
            U4 _7; // 0
            U4 _8; // 0
            U4 _9; // 0
            U4 _a; // 0
            U4 _b; // 0
            U4 _c; // 0
            U4 _d; // 0
        break;
    }

    Padding();
};

// RENDER MESH DEFINE
typedef struct DNER
{
    ILFF_HEADER header;

    switch(igi1_mef.hsem.mt)
    {
        case 0:
        case 1:
        struct
        {
            F4 _0;
            F4 _1;
            F4 _2;
            S2 _3;
            S2 _4;
            S2 _5;
            S2 _6;
            S2 _7;
            S2 _8;
            S2 _9;
            S2 _a;
            U2 face[_3];
        } mesh[igi1_mef.d3dr.mc] <optimize=false>;
        break;

        case 3:
        struct
        {
            F4 _0;
            F4 _1;
            F4 _2;
            S2 _3;
            S2 _4;
            S2 _5;
            S2 _6;
            S2 _7;
            S2 _8;
            S2 _9;
            S2 _a;
            S2 _b;
            S2 _c;
            U2 face[_3];
        } mesh[igi1_mef.d3dr.mc] <optimize=false>;
        break;
    }

    Padding();
};

// RENDER MESH VERTICES
typedef struct XTRV
{
    ILFF_HEADER header;

    switch(igi1_mef.hsem.mt)
    {
        case 0:
        struct
        {
            F4 _0;
            F4 _1;
            F4 _2;
            F4 _3;
            F4 _4;
            F4 _5;
            F4 _6;
            F4 _7;
        } vertex[header.datasize / 32];
        break;

        case 1:
        case 3:
        struct
        {
            F4 _0;
            F4 _1;
            F4 _2;
            F4 _3;
            F4 _4;
            F4 _5;
            F4 _6;
            F4 _7;
            F4 _8;
            F4 _9;
        } vertex[header.datasize / 40];
        break;
    }

    Padding();
};

// RENDER MESH LIGHTMAPS
typedef struct PMTL
{
    ILFF_HEADER header;

    struct
    {
        U2 _0;  // {1 - 1024}
        U2 _1;  // {1 - 904}
        U2 _2;  // 0
        U2 _3;  // 0
    } unk[header.datasize / 8];

    Padding();
};

// COLLISION MESH HEADER
typedef struct HSMC
{
    ILFF_HEADER header;

    U4 n_face_0;
    U4 n_vertex_0;
    U4 n_material_0;
    U4 n_sph_0;
    U4 _0;           // 0
    U4 _1;           // 0
    U4 _2;           // 0
    U4 _3;           // 0
    U4 n_face_1;
    U4 n_vertex_1;
    U4 n_material_1;
    U4 n_sph_1;
    U4 _4;           // 0
    U4 _5;           // 0
    U4 _6;           // 0
    U4 _7;           // 0

    Padding();
};

// COLLISION MESH VERTICES
typedef struct XTVC
{
    ILFF_HEADER header;

    struct
    {
        F4 _0;
        F4 _1;
        F4 _2;
        F4 _3;
    } vertex[header.datasize / 16];

    Padding();
};

// COLLISION MESH FACES
typedef struct ECFC
{
    ILFF_HEADER header;

    struct
    {
        U2 _0;
        U2 _1;
        U2 _2;
        U2 _3;
    } face[header.datasize / 8];

    Padding();
};

// COLLISION MESH MATERIALS
typedef struct TAMC
{
    ILFF_HEADER header;

    struct
    {
        S2 _0;
        S2 _1;
        S2 _2;
        S2 _3;
        S2 _4;
        S2 _5;
    } material[header.datasize / 12];

    Padding();
};

// COLLISION MESH SPH
typedef struct HPSC
{
    ILFF_HEADER header;

    struct
    {
        F4 _0;  // -4300800.0  1645731.8  560655
        F4 _1;  // -1232424.9  2430292.0  536491
        F4 _2;  // -2059984.9  784330.7   499694
        F4 _3;  //  0.0        4270366.5  696317
        S2 _4;  // -1          14794      14796
        S2 _5;  //  {0, 1}
        S2 _6;  //  0          29588      23207
        S2 _7;  //  0          29586      21872
    } sph [header.datasize / 24];

    Padding();
};

// TXAN
typedef struct TXAN
{
    ILFF_HEADER header;

    U4 _00; // {25}
    U4 _01; // {26}
    U4 _02; // {0}
    U4 _03; // {1}
    U4 _04; // {2}
    U4 _05; // {3}
    U4 _06; // {4}
    U4 _07; // {5}
    U4 _08; // {6}
    U4 _09; // {7}
    U4 _10; // {8}
    U4 _11; // {9}
    U4 _12; // {10}
    U4 _13; // {11}
    U4 _14; // {12}
    U4 _15; // {13}
    U4 _16; // {14}
    U4 _17; // {15}
    U4 _18; // {16}
    U4 _19; // {17}
    U4 _20; // {18}
    U4 _21; // {19}
    U4 _22; // {20}
    U4 _23; // {21}
    U4 _24; // {22}
    U4 _25; // {23}
    U4 _26; // {24}
    U4 _27; // {25}

    Padding();
};




struct
{
    ILFF_HEADER header;
    CH formatid[4];  // OCEM

    while(FTell() < FileSize())
    {
        switch(ReadString(FTell(), 4))
        {
            case "HSEM": HSEM hsem; break;
            case "ATTA": ATTA atta; break;
            case "XTVM": XTVM xtvm; break;
            case "TROP": TROP trop; break;
            case "XVTP": XVTP xvtp; break;
            case "CFTP": CFTP cftp; break;
            case "D3DR": D3DR d3dr; break;
            case "DNER": DNER dner; break;
            case "XTRV": XTRV xtrv; break;
            case "PMTL": PMTL pmtl; break;
            case "HSMC": HSMC hsmc; break;
            case "XTVC": XTVC xtvc; break;
            case "ECFC": ECFC ecfc; break;
            case "TAMC": TAMC tamc; break;
            case "HPSC": HPSC hpsc; break;
            case "TXAN": TXAN txan; break;
            default: Assert(false, "Parsing error: unhandled block type");
        }
    }
} igi1_mef;


Assert(FEof(), "Parsing error: expected end of file");

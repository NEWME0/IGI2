//------------------------------------------------
//--- 010 Editor v9.0.1 Binary Template
//
//      File: IGI2_QVM.bt
//   Authors: Rotari Artiom
//   Version: 1.0
//   Purpose: 
//  Category: Game
// File Mask: LOOP
//  ID BYTEs: 
//   History: 
//------------------------------------------------

/*
opcodes from gconvapi

ILLEGAL   |       |
BLK       |       |
NOT       |  yes  |
INV       |  yes  |
MINUS     |  yes  |
PLUS      |  yes  |
ASSIGN    |  yes  |
GE        |  yes  |
GT        |  yes  |
LE        |  yes  |
LT        |  yes  |
NE        |  yes  |
EQ        |  yes  |
LOR       |  yes  |
LAND      |  yes  |
XOR       |  yes  |
OR        |  yes  |
AND       |  yes  |
SHR       |  yes  |
SHL       |  yes  |
DIV       |  yes  |
MUL       |  yes  |
SUB       |  yes  |
ADD       |  yes  |
CALL      |  yes  |
JSR       |       |
BT        |       |
BF        |  yes  |
BRA       |  yes  |
RET       |       |
POP       |  yes  |
PUSHM     |       |
PUSH1     |  yes  |
PUSH0     |  yes  |
PUSHIIW   |       |
PUSHIIB   |       |
PUSHII    |       |
PUSHI     |       |
PUSHSIW   |       |
PUSHSIB   |       |
PUSHSI    |       |
PUSHS     |       |
PUSHA     |       |
PUSHF     |  yes  |
PUSHW     |       |
PUSHB     |       |
PUSH      |       |
NOP       |       |
BRK       |  yes  |
*/



#include "COMMON/CSTRING.bt";


typedef struct
{
    UBYTE value;
} PUSHIIB <read=READ_PUSHIIB>;


typedef struct
{
    UINT16 value;
} PUSHIIW <read=READ_PUSHIIW>;


typedef struct
{
    UINT32 value;
} PUSHII <read=READ_PUSHII>;


typedef struct
{
    UBYTE value;
} PUSHSIB <read=READ_PUSHSIB>;


typedef struct
{
    UINT16 value;
} PUSHSIW <read=READ_PUSHSIW>;


typedef struct
{
    UINT32 value;
} PUSHSI <read=READ_PUSHSI>;


typedef struct
{
    UBYTE type;

    switch(type)
    {
        case 0:  break;                  // BRK
        //case 1:  break;                  // NOP
        //case 2:  break;                  // RET
        case 3:  INT32    value; break;  // BRA
        case 4:  UINT32   value; break;  // BF
        //case 5:  break;                  // BT
        //case 6:  break;                  // JSR
        case 7: {                        // CALL
            UINT32 count;
            if(count > 0)
                UINT32 value[count];
        } break;
        case 8:  UINT32   value; break;  // PUSH
        case 9:  UBYTE    value; break;  // PUSHB
        case 10: UINT16   value; break;  // PUSHW
        case 11: FLOAT    value; break;  // PUSHF
        //case 12: break;                  // PUSHA
        //case 13: break;                  // PUSHS
        case 14: PUSHSI   value  break;  // PUSHSI
        case 15: PUSHSIB  value; break;  // PUSHSIB
        case 16: PUSHSIW  value; break;  // PUSHSIW
        //case 17: break;                  // PUSHI
        case 18: PUSHII   value; break;  // PUSHII
        case 19: PUSHIIB  value; break;  // PUSHIIB
        case 20: PUSHIIW  value; break;  // PUSHIIW
        case 21: break;                  // PUSH0
        case 22: break;                  // PUSH1
        case 23: break;                  // PUSHM
        case 24: break;                  // POP
        case 25: break;                  // ADD +
        case 26: break;                  // SUB -
        case 27: break;                  // MUL *
        case 28: break;                  // DIV /
        case 29: break;                  // SHL <<
        case 30: break;                  // SHR >>
        case 31: break;                  // AND &
        case 32: break;                  // OR |
        case 33: break;                  // XOR ^
        case 34: break;                  // LAND &&
        case 35: break;                  // LOR ||
        case 36: break;                  // EQ ==
        case 37: break;                  // NE !=
        case 38: break;                  // LT <
        case 39: break;                  // LE <=
        case 40: break;                  // GT >
        case 41: break;                  // GE >=
        case 42: break;                  // ASSIGN =
        case 43: break;                  // PLUS +
        case 44: break;                  // MINUS -
        case 45: break;                  // INV ~
        case 46: break;                  // NOT !
        //case 47: break;                  // BLK
        //case 48: break;                  // ILLEGAL

        default: {
            Printf("SKIP at %u with TYPE %u\n", FTell(), type);
        }
    }
} OPCODE <read=READ_OPCODE>;


struct
{
    CHAR   magic[4]; // LOOP
    UINT32 _0; // 7
    UINT32 _1; // 8
    UINT32 offset_identifiers_offsets;
    UINT32 offset_identifiers;
    UINT32 size_identifiers_offsets;
    UINT32 size_identifiers;
    UINT32 offset_strings_offsets;
    UINT32 offset_strings;
    UINT32 size_strings_offsets;
    UINT32 size_strings;
    UINT32 offset_opcodes;
    UINT32 size_opcodes;
    UINT32 _2;
    UINT32 _3;
    UINT32 offset_tail;


    if(size_identifiers_offsets > 0)
    UINT32 identifiers_offset[size_identifiers_offsets / 4];


    if(size_identifiers > 0)
    CSTRING identifiers[size_identifiers_offsets / 4] <optimize=false>;


    if(size_strings_offsets > 0)
    UINT32 strings_offsets[size_strings_offsets / 4];


    if(size_strings > 0)
    CSTRING strings[size_strings_offsets / 4] <optimize=false>;


    if(size_opcodes > 0)
    struct
    {
        while(FTell() < offset_opcodes + size_opcodes)
            OPCODE opcode;
    } opcodes;


    if(offset_tail > 0)
    UBYTE tail[FileSize() - offset_tail];
} igi2_qvm;


Assert(FEof());


string READ_PUSHIIB(PUSHIIB &o) {
    return igi2_qvm.identifiers[o.value].value;
};

string READ_PUSHIIW(PUSHIIW &o) {
    return igi2_qvm.identifiers[o.value].value;
};

string READ_PUSHII(PUSHII &o) {
    return igi2_qvm.identifiers[o.value].value;
};

string READ_PUSHSIB(PUSHSIB &o) {
    return igi2_qvm.strings[o.value].value;
};

string READ_PUSHSIW(PUSHSIW &o) {
    return igi2_qvm.strings[o.value].value;
};

string READ_PUSHSI(PUSHSI &o) {
    return igi2_qvm.strings[o.value].value;
};

string READ_OPCODE(OPCODE &o) {
    switch(o.type)
    {
        case 0:  return "BRK";
        //case 1:  return "NOP";
        //case 2:  return "RET";
        case 3:  return "BRA";
        case 4:  return "BF";
        //case 5:  return "BT";
        //case 6:  return "JSR";
        case 7:  return "CALL";
        case 8:  return "PUSH";
        case 9:  return "PUSHB";
        case 10: return "PUSHW";
        case 11: return "PUSHF";
        //case 12: return "PUSHA";
        //case 13: return "PUSHS";
        case 14: return "PUSHSI";
        case 15: return "PUSHSIB";
        case 16: return "PUSHSIW";
        //case 17: return "PUSHI";
        case 18: return "PUSHII";
        case 19: return "PUSHIIB";
        case 20: return "PUSHIIW";
        case 21: return "PUSH0";
        case 22: return "PUSH1";
        case 23: return "PUSHM"; // MAX
        case 24: return "POP";
        case 25: return "ADD";
        case 26: return "SUB";
        case 27: return "MUL";
        case 28: return "DIV";
        case 29: return "SHL";
        case 30: return "SHR";
        case 31: return "AND";
        case 32: return "OR";
        case 33: return "XOR";
        case 34: return "LAND";
        case 35: return "LOR";
        case 36: return "EQ";
        case 37: return "NE";
        case 38: return "LT";
        case 39: return "LE";
        case 40: return "GT";
        case 41: return "GE";
        case 42: return "ASSIGN";
        case 43: return "PLUS";
        case 44: return "MINUS";
        case 45: return "INV";
        case 46: return "NOT";
        //case 47: return "BLK";
        //case 48: return "ILLEGAL";

        default: return "__UNKNOWN__";
    }
}
